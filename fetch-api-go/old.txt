package main

import (
	"encoding/json"
	"fmt"
	"io"
	"io/ioutil"
	"net/http"
	"os"
	"sort"
	"strconv"
	"time"

	"github.com/gin-contrib/cors"
	"github.com/gin-gonic/gin"
	"github.com/golang-jwt/jwt/v4"
	"github.com/joho/godotenv"
)

const (
	resourceURL        = "https://60c18de74f7e880017dbfd51.mockapi.io/api/v1/jabar-digital-services/product"
	currencyAPIURL     = "https://free.currencyconverterapi.com/api/v6/convert?q=USD_IDR&compact=ultra"
	currencyAPIKey     = "your_currency_api_key_here"
	adminRole          = "admin"
	tokenHeader        = "Authorization"
	defaultCurrencyKey = "USD_IDR"
)

type product struct {
	ID         string  `json:"id"`
	Name       string  `json:"name"`
	Price      string  `json:"price"`
	Department string  `json:"department"`
	PriceIDR   float64 `json:"price_idr, omitempty"`
}

var usdToIdrRate float64 = 1550.5
var jwtKeySecret string

func init() {
	if err := godotenv.Load(); err != nil {
		fmt.Println(".env file is not found xxixii")
	}

	jwtKeySecret = os.Getenv("JWT_KEY_SECRET")

}

func validateJWT() gin.HandlerFunc {
	return func(c *gin.Context) {
		authHeader := c.GetHeader("Authorization")
		if authHeader == "" {
			c.JSON(http.StatusUnauthorized, gin.H{"error": "Token required"})
			c.Abort()
			return
		}

		tokenStr := authHeader[len("Bearer "):]
		token, err := jwt.Parse(tokenStr, func(token *jwt.Token) (interface{}, error) {
			if _, ok := token.Method.(*jwt.SigningMethodHMAC); !ok {
				return nil, fmt.Errorf("unexpected signing method")
			}
			return []byte(jwtKeySecret), nil
		})

		if err != nil || !token.Valid {
			c.JSON(http.StatusUnauthorized, gin.H{"error": "Invalid token"})
			c.Abort()
			return
		}

		c.Next()
	}
}

func fetchProducts(c *gin.Context) {
	resp, err := http.Get(resourceURL)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to fetch products"})
		return
	}
	defer resp.Body.Close()

	body, _ := io.ReadAll(resp.Body)
	// fmt.Println("Raw JSON:", string(body))

	var products []product
	if err := json.Unmarshal(body, &products); err != nil {
		// fmt.Println("Unmarshal error:", err)
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to parse products"})
		return
	}
	// fmt.Println("Parsed products:", products) // Log parsed data

	c.JSON(http.StatusOK, gin.H{"products": products})
}

func aggregateProducts(c *gin.Context) {
	// claims := c.MustGet("claims").(jwt.MapClaims)
	// role := claims["role"].(string)

	// if role != adminRole {
	// 	c.JSON(http.StatusForbidden, gin.H{"error": "Unauthorized role"})
	// 	return
	// }
	// /api/products/aggreg
	response, err := http.Get(resourceURL)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to fetch products"})
		return
	}
	defer response.Body.Close()

	body, err := ioutil.ReadAll(response.Body)
	if err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to read response"})
		return
	}

	var products []product
	if err := json.Unmarshal(body, &products); err != nil {
		c.JSON(http.StatusInternalServerError, gin.H{"error": "Failed to parse products"})
		return
	}

	for i, product := range products {
		// fmt.Println("Product price:", c.GetFloat64(product.Price))
		p1, _ := strconv.ParseFloat(product.Price, 32)
		products[i].PriceIDR = p1 * usdToIdrRate
	}
	sort.Slice(products, func(i, j int) bool {
		return products[i].PriceIDR < products[j].PriceIDR
	})

	c.JSON(http.StatusOK, products)
}

func privateClaims(c *gin.Context) {
	claims := c.MustGet("claims").(jwt.MapClaims)
	c.JSON(http.StatusOK, claims)
}

func index(c *gin.Context) {
	c.IndentedJSON(http.StatusOK, gin.H{"messsage": "Backend succesfully connected!"})
}

func showIndex(router *gin.Engine) {
	router.GET("/", index)
}

func main() {

	router := gin.Default()
	router.Use(cors.New(cors.Config{
		AllowOrigins:  []string{"http://localhost:9000"},
		AllowMethods:  []string{"POST", "DELETE", "GET", "PUT"},
		AllowHeaders:  []string{"Origin", "Content-type", "Authorization"},
		ExposeHeaders: []string{"Content-Length"},
		MaxAge:        12 * time.Hour,
	}))

	showIndex(router)

	authorized := router.Group("/api", validateJWT())
	{
		authorized.GET("/products", fetchProducts)
		authorized.GET("/products/aggregate", aggregateProducts)
		authorized.GET("/claims", privateClaims)
	}

	router.Run("localhost:8181")

}
